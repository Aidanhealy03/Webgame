<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Goblin FBX Walker</title>
  <style>
    * { box-sizing: border-box; }
    body {
      margin: 0;
      overflow: hidden;
      font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      background: #111;
      color: #f5f5f5;
    }
    #app {
      width: 100vw;
      height: 100vh;
      position: relative;
    }
    #hud {
      position: absolute;
      top: 12px;
      left: 12px;
      right: 12px;
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      pointer-events: none;
      gap: 12px;
    }
    .panel {
      background: rgba(0, 0, 0, 0.55);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 10px;
      padding: 10px 12px;
      font-size: 14px;
      line-height: 1.35;
      backdrop-filter: blur(2px);
      max-width: min(520px, 95vw);
    }
    #status {
      color: #ffdd9e;
      font-weight: 700;
    }
    code {
      background: rgba(255,255,255,0.1);
      padding: 2px 4px;
      border-radius: 4px;
    }
  </style>
</head>
<body>
  <div id="app"></div>
  <div id="hud">
    <div class="panel">
      <div><strong>Controls:</strong> WASD move, Space jump</div>
      <div><strong>Animations:</strong> Idle / Walk / Jump (from your FBX files)</div>
    </div>
    <div class="panel" id="status">Loading goblin assets...</div>
  </div>

  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.160.1/build/three.module.js';
    import { OrbitControls } from 'https://unpkg.com/three@0.160.1/examples/jsm/controls/OrbitControls.js';
    import { FBXLoader } from 'https://unpkg.com/three@0.160.1/examples/jsm/loaders/FBXLoader.js';

    /**
     * Update these paths to match the files you add to this repo.
     * Example layout:
     * assets/goblin/goblin.fbx
     * assets/animations/walk.fbx
     * assets/animations/jump.fbx
     */
    const ASSET_PATHS = {
      model: './assets/goblin/goblin.fbx',
      walk: './assets/animations/walk.fbx',
      jump: './assets/animations/jump.fbx'
    };

    const app = document.getElementById('app');
    const statusEl = document.getElementById('status');

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x1e2433);
    scene.fog = new THREE.Fog(0x1e2433, 18, 90);

    const camera = new THREE.PerspectiveCamera(60, 1, 0.1, 200);
    camera.position.set(0, 5, 11);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    app.appendChild(renderer.domElement);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.target.set(0, 2, 0);

    const hemi = new THREE.HemisphereLight(0xbecbff, 0x202020, 1.0);
    scene.add(hemi);

    const sun = new THREE.DirectionalLight(0xffffff, 1.2);
    sun.position.set(8, 14, 10);
    sun.castShadow = true;
    sun.shadow.mapSize.set(2048, 2048);
    scene.add(sun);

    const ground = new THREE.Mesh(
      new THREE.PlaneGeometry(120, 120),
      new THREE.MeshStandardMaterial({ color: 0x45605a, roughness: 0.95, metalness: 0.02 })
    );
    ground.rotation.x = -Math.PI / 2;
    ground.receiveShadow = true;
    scene.add(ground);

    const grid = new THREE.GridHelper(120, 120, 0x99bbcc, 0x66808a);
    grid.position.y = 0.01;
    scene.add(grid);

    const keys = Object.create(null);
    window.addEventListener('keydown', (e) => {
      keys[e.code] = true;
      if (['Space', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.code)) e.preventDefault();
    });
    window.addEventListener('keyup', (e) => { keys[e.code] = false; });

    const clock = new THREE.Clock();
    const loader = new FBXLoader();

    let goblin;
    let mixer;
    const actions = { idle: null, walk: null, jump: null };
    let activeActionName = 'idle';

    const player = {
      velocity: new THREE.Vector3(),
      moveSpeed: 4.5,
      jumpSpeed: 7.5,
      gravity: 20,
      onGround: true
    };

    function setStatus(msg, isError = false) {
      statusEl.textContent = msg;
      statusEl.style.color = isError ? '#ff9ca3' : '#ffdd9e';
    }

    function playAction(name, fade = 0.15) {
      if (!actions[name] || activeActionName === name) return;
      const next = actions[name];
      const current = actions[activeActionName];
      next.reset().fadeIn(fade).play();
      if (current) current.fadeOut(fade);
      activeActionName = name;
    }

    function makeIdleClipFromCurrentPose(model) {
      const idleTracks = [];
      model.traverse((obj) => {
        if (!obj.isBone) return;
        idleTracks.push(new THREE.VectorKeyframeTrack(`${obj.name}.position`, [0], obj.position.toArray()));
        idleTracks.push(new THREE.QuaternionKeyframeTrack(`${obj.name}.quaternion`, [0], obj.quaternion.toArray()));
        idleTracks.push(new THREE.VectorKeyframeTrack(`${obj.name}.scale`, [0], obj.scale.toArray()));
      });
      return new THREE.AnimationClip('idle_pose', 1, idleTracks);
    }

    async function loadFbx(path, label) {
      return new Promise((resolve, reject) => {
        loader.load(path, resolve, undefined, (err) => reject(new Error(`Failed to load ${label}: ${err?.message || err}`)));
      });
    }

    async function initGoblin() {
      try {
        const modelFbx = await loadFbx(ASSET_PATHS.model, 'model FBX');
        goblin = modelFbx;
        goblin.scale.setScalar(0.01);
        goblin.position.set(0, 0, 0);
        goblin.traverse((obj) => {
          if (obj.isMesh) {
            obj.castShadow = true;
            obj.receiveShadow = true;
          }
        });
        scene.add(goblin);

        mixer = new THREE.AnimationMixer(goblin);

        if (modelFbx.animations?.length) {
          actions.idle = mixer.clipAction(modelFbx.animations[0]);
        } else {
          actions.idle = mixer.clipAction(makeIdleClipFromCurrentPose(goblin));
        }

        const walkFbx = await loadFbx(ASSET_PATHS.walk, 'walk animation FBX');
        if (walkFbx.animations?.[0]) {
          actions.walk = mixer.clipAction(walkFbx.animations[0]);
          actions.walk.loop = THREE.LoopRepeat;
          actions.walk.clampWhenFinished = false;
        }

        const jumpFbx = await loadFbx(ASSET_PATHS.jump, 'jump animation FBX');
        if (jumpFbx.animations?.[0]) {
          actions.jump = mixer.clipAction(jumpFbx.animations[0]);
          actions.jump.loop = THREE.LoopOnce;
          actions.jump.clampWhenFinished = true;
        }

        actions.idle?.play();
        activeActionName = 'idle';

        setStatus('Loaded. Move with WASD, jump with Space.');
      } catch (err) {
        console.error(err);
        setStatus(`${err.message}. Check ASSET_PATHS in index.html.`, true);
      }
    }

    function updatePlayer(dt) {
      if (!goblin) return;

      const inputX = ((keys.KeyD || keys.ArrowRight) ? 1 : 0) - ((keys.KeyA || keys.ArrowLeft) ? 1 : 0);
      const inputZ = ((keys.KeyS || keys.ArrowDown) ? 1 : 0) - ((keys.KeyW || keys.ArrowUp) ? 1 : 0);

      const moveVec = new THREE.Vector3(inputX, 0, inputZ);
      const moving = moveVec.lengthSq() > 0;

      if (moving) {
        moveVec.normalize().multiplyScalar(player.moveSpeed * dt);
        goblin.position.add(moveVec);
        const yaw = Math.atan2(moveVec.x, moveVec.z);
        goblin.rotation.y = yaw;
      }

      if (keys.Space && player.onGround) {
        player.velocity.y = player.jumpSpeed;
        player.onGround = false;
        playAction('jump', 0.08);
      }

      player.velocity.y -= player.gravity * dt;
      goblin.position.y += player.velocity.y * dt;

      if (goblin.position.y <= 0) {
        goblin.position.y = 0;
        player.velocity.y = 0;
        player.onGround = true;
      }

      if (!player.onGround) {
        playAction('jump', 0.08);
      } else if (moving && actions.walk) {
        playAction('walk', 0.1);
      } else {
        playAction('idle', 0.2);
      }

      if (actions.jump && activeActionName === 'jump' && player.onGround) {
        const jumpClipDone = actions.jump.time >= actions.jump.getClip().duration - 0.05;
        if (jumpClipDone) {
          playAction(moving && actions.walk ? 'walk' : 'idle', 0.1);
          actions.jump.stop();
        }
      }

      const camFollow = new THREE.Vector3(goblin.position.x, 2, goblin.position.z);
      controls.target.lerp(camFollow, 0.12);
    }

    function resize() {
      const w = app.clientWidth;
      const h = app.clientHeight;
      camera.aspect = w / h;
      camera.updateProjectionMatrix();
      renderer.setSize(w, h, false);
    }

    window.addEventListener('resize', resize);
    resize();

    function animate() {
      requestAnimationFrame(animate);
      const dt = Math.min(0.033, clock.getDelta());
      if (mixer) mixer.update(dt);
      updatePlayer(dt);
      controls.update();
      renderer.render(scene, camera);
    }

    initGoblin();
    animate();
  </script>
</body>
</html>
